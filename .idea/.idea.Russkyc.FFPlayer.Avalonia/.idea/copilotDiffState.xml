<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Sample/MediaFramePlayer.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Sample/MediaFramePlayer.cs" />
              <option name="originalContent" value="using System;&#10;using System.ComponentModel;&#10;using System.Runtime.CompilerServices;&#10;using System.Runtime.InteropServices;&#10;using System.Threading;&#10;using Avalonia.Media.Imaging;&#10;using Avalonia.Platform;&#10;using Avalonia.Threading;&#10;using LibVLCSharp.Shared;&#10;&#10;namespace Sample;&#10;&#10;public sealed class MediaFramePlayer : INotifyPropertyChanged, IDisposable&#10;{&#10;    #region Fields&#10;    &#10;    private readonly MediaPlayer _player;&#10;    private readonly Lock _bufferLock = new();&#10;    &#10;    private WriteableBitmap? _currentFrame;&#10;    private IntPtr _videoBuffer = IntPtr.Zero;&#10;    private uint _videoHeight;&#10;    private uint _videoPitch;&#10;    private bool _isDisposed;&#10;    &#10;    #endregion&#10;&#10;    #region Properties&#10;    &#10;    public WriteableBitmap? CurrentFrame&#10;    {&#10;        get =&gt; _currentFrame;&#10;        private set&#10;        {&#10;            _currentFrame = value;&#10;            OnPropertyChanged();&#10;        }&#10;    }&#10;    &#10;    #endregion&#10;&#10;    #region Events&#10;    &#10;    public event PropertyChangedEventHandler? PropertyChanged;&#10;    &#10;    #endregion&#10;&#10;    #region Initialization&#10;    &#10;    public MediaFramePlayer()&#10;    {&#10;        _player = new MediaPlayer(App.LibVlc);&#10;        &#10;        ConfigureVideoCallbacks();&#10;    }&#10;&#10;    private void ConfigureVideoCallbacks()&#10;    {&#10;        _player.SetVideoFormatCallbacks(VideoFormat, CleanupVideo);&#10;        _player.SetVideoCallbacks(LockVideo, null, DisplayVideo);&#10;    }&#10;    &#10;    #endregion&#10;&#10;    #region Public Methods&#10;    &#10;    public void Play(string mediaPath)&#10;    {&#10;        if (_isDisposed)&#10;            throw new ObjectDisposedException(nameof(MediaFramePlayer));&#10;        &#10;        var media = new Media(App.LibVlc, mediaPath);&#10;        _player.Play(media);&#10;    }&#10;&#10;    public void Stop()&#10;    {&#10;        _player.Stop();&#10;    }&#10;&#10;    public void Pause()&#10;    {&#10;        _player.Pause();&#10;    }&#10;    &#10;    #endregion&#10;&#10;    #region Video Callbacks&#10;    &#10;    private uint VideoFormat(ref IntPtr opaque, IntPtr chroma, ref uint width, ref uint height, &#10;        ref uint pitches, ref uint lines)&#10;    {&#10;        SetVideoFormat(chroma, width, height, ref pitches, ref lines);&#10;        AllocateVideoBuffer();&#10;        CreateBitmap(width, height);&#10;        &#10;        return 1;&#10;    }&#10;&#10;    private void SetVideoFormat(IntPtr chroma, uint width, uint height, ref uint pitches, ref uint lines)&#10;    {&#10;        ArgumentOutOfRangeException.ThrowIfNegative(lines);&#10;        ArgumentOutOfRangeException.ThrowIfNegative(pitches);&#10;        // Use RV32 (BGRA) format - native to Avalonia for optimal quality&#10;        Marshal.Copy(&quot;RV32&quot;u8.ToArray(), 0, chroma, 4);&#10;        &#10;        _videoHeight = height;&#10;        _videoPitch = width * 4; // 4 bytes per pixel (BGRA)&#10;        &#10;        pitches = _videoPitch;&#10;        lines = height;&#10;    }&#10;&#10;    private void AllocateVideoBuffer()&#10;    {&#10;        var bufferSize = GetBufferSize();&#10;        &#10;        lock (_bufferLock)&#10;        {&#10;            FreeVideoBuffer();&#10;            _videoBuffer = Marshal.AllocHGlobal(bufferSize);&#10;        }&#10;    }&#10;&#10;    private void CreateBitmap(uint width, uint height)&#10;    {&#10;        Dispatcher.UIThread.InvokeAsync(() =&gt;&#10;        {&#10;            CurrentFrame = new WriteableBitmap(&#10;                new Avalonia.PixelSize((int)width, (int)height),&#10;                new Avalonia.Vector(96, 96),&#10;                PixelFormat.Bgra8888,&#10;                AlphaFormat.Opaque);&#10;        }).Wait();&#10;    }&#10;&#10;    private IntPtr LockVideo(IntPtr opaque, IntPtr planes)&#10;    {&#10;        lock (_bufferLock)&#10;        {&#10;            Marshal.WriteIntPtr(planes, _videoBuffer);&#10;        }&#10;        return IntPtr.Zero;&#10;    }&#10;&#10;    private void DisplayVideo(IntPtr opaque, IntPtr picture)&#10;    {&#10;        if (!IsVideoReady()) return;&#10;&#10;        var frameData = CopyFrameData();&#10;        UpdateFrameOnUiThread(frameData);&#10;    }&#10;&#10;    private void CleanupVideo(ref IntPtr opaque)&#10;    {&#10;        lock (_bufferLock)&#10;        {&#10;            FreeVideoBuffer();&#10;        }&#10;    }&#10;    &#10;    #endregion&#10;&#10;    #region Frame Processing&#10;    &#10;    private bool IsVideoReady()&#10;    {&#10;        return CurrentFrame != null &amp;&amp; _videoBuffer != IntPtr.Zero;&#10;    }&#10;&#10;    private IntPtr CopyFrameData()&#10;    {&#10;        var bufferSize = GetBufferSize();&#10;        var tempBuffer = Marshal.AllocHGlobal(bufferSize);&#10;        &#10;        lock (_bufferLock)&#10;        {&#10;            unsafe&#10;            {&#10;                Buffer.MemoryCopy(&#10;                    _videoBuffer.ToPointer(),&#10;                    tempBuffer.ToPointer(),&#10;                    bufferSize,&#10;                    bufferSize);&#10;            }&#10;        }&#10;        &#10;        return tempBuffer;&#10;    }&#10;&#10;    private void UpdateFrameOnUiThread(IntPtr frameBuffer)&#10;    {&#10;        Dispatcher.UIThread.InvokeAsync(() =&gt;&#10;        {&#10;            try&#10;            {&#10;                CopyFrameToWriteableBitmap(frameBuffer);&#10;                OnPropertyChanged(nameof(CurrentFrame));&#10;            }&#10;            finally&#10;            {&#10;                Marshal.FreeHGlobal(frameBuffer);&#10;            }&#10;        }, DispatcherPriority.Send);&#10;    }&#10;&#10;    private void CopyFrameToWriteableBitmap(IntPtr sourceBuffer)&#10;    {&#10;        if (CurrentFrame == null) return;&#10;        &#10;        var bufferSize = GetBufferSize();&#10;        var bitmap = new WriteableBitmap(CurrentFrame.PixelSize, CurrentFrame.Dpi, CurrentFrame.Format,&#10;            CurrentFrame.AlphaFormat);&#10;        using var frameBuffer = bitmap.Lock();&#10;        unsafe&#10;        {&#10;            Buffer.MemoryCopy(&#10;                sourceBuffer.ToPointer(),&#10;                frameBuffer.Address.ToPointer(),&#10;                bufferSize,&#10;                bufferSize);&#10;        }&#10;        CurrentFrame = bitmap;&#10;    }&#10;    &#10;    #endregion&#10;&#10;    #region Helper Methods&#10;    &#10;    private int GetBufferSize()&#10;    {&#10;        return (int)(_videoPitch * _videoHeight);&#10;    }&#10;&#10;    private void FreeVideoBuffer()&#10;    {&#10;        if (_videoBuffer != IntPtr.Zero)&#10;        {&#10;            Marshal.FreeHGlobal(_videoBuffer);&#10;            _videoBuffer = IntPtr.Zero;&#10;        }&#10;    }&#10;&#10;    private void OnPropertyChanged([CallerMemberName] string? propertyName = null)&#10;    {&#10;        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));&#10;    }&#10;    &#10;    #endregion&#10;&#10;    #region Disposal&#10;    &#10;    public void Dispose()&#10;    {&#10;        if (_isDisposed) return;&#10;        &#10;        _player.Stop();&#10;        _player.Dispose();&#10;        &#10;        lock (_bufferLock)&#10;        {&#10;            FreeVideoBuffer();&#10;        }&#10;        &#10;        _isDisposed = true;&#10;        GC.SuppressFinalize(this);&#10;    }&#10;    &#10;    #endregion&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.ComponentModel;&#10;using System.Runtime.CompilerServices;&#10;using System.Runtime.InteropServices;&#10;using System.Threading;&#10;using Avalonia.Media.Imaging;&#10;using Avalonia.Platform;&#10;using Avalonia.Threading;&#10;using LibVLCSharp.Shared;&#10;&#10;namespace Sample;&#10;&#10;public sealed class MediaFramePlayer : INotifyPropertyChanged, IDisposable&#10;{&#10;    #region Fields&#10;    &#10;    private readonly MediaPlayer _player;&#10;    private readonly Lock _bufferLock = new();&#10;    &#10;    private WriteableBitmap? _currentFrame;&#10;    private IntPtr _videoBuffer = IntPtr.Zero;&#10;    private uint _videoHeight;&#10;    private uint _videoPitch;&#10;    private bool _isDisposed;&#10;    private long _lastRenderTicks;&#10;    private const int TargetFps = 30; // adjust if you want smoother/faster updates&#10;    &#10;    #endregion&#10;&#10;    #region Properties&#10;    &#10;    public WriteableBitmap? CurrentFrame&#10;    {&#10;        get =&gt; _currentFrame;&#10;        private set&#10;        {&#10;            if (ReferenceEquals(_currentFrame, value))&#10;                return;&#10;&#10;            _currentFrame = value;&#10;            OnPropertyChanged();&#10;        }&#10;    }&#10;    &#10;    #endregion&#10;&#10;    #region Events&#10;    &#10;    public event PropertyChangedEventHandler? PropertyChanged;&#10;    &#10;    #endregion&#10;&#10;    #region Initialization&#10;    &#10;    public MediaFramePlayer()&#10;    {&#10;        _player = new MediaPlayer(App.LibVlc);&#10;        &#10;        ConfigureVideoCallbacks();&#10;    }&#10;&#10;    private void ConfigureVideoCallbacks()&#10;    {&#10;        _player.SetVideoFormatCallbacks(VideoFormat, CleanupVideo);&#10;        _player.SetVideoCallbacks(LockVideo, null, DisplayVideo);&#10;    }&#10;    &#10;    #endregion&#10;&#10;    #region Public Methods&#10;    &#10;    public void Play(string mediaPath)&#10;    {&#10;        if (_isDisposed)&#10;            throw new ObjectDisposedException(nameof(MediaFramePlayer));&#10;        &#10;        var media = new Media(App.LibVlc, mediaPath);&#10;        _player.Play(media);&#10;    }&#10;&#10;    public void Stop()&#10;    {&#10;        _player.Stop();&#10;    }&#10;&#10;    public void Pause()&#10;    {&#10;        _player.Pause();&#10;    }&#10;    &#10;    #endregion&#10;&#10;    #region Video Callbacks&#10;    &#10;    private uint VideoFormat(ref IntPtr opaque, IntPtr chroma, ref uint width, ref uint height, &#10;        ref uint pitches, ref uint lines)&#10;    {&#10;        SetVideoFormat(chroma, width, height, ref pitches, ref lines);&#10;        AllocateVideoBuffer();&#10;        CreateBitmap(width, height);&#10;        &#10;        return 1;&#10;    }&#10;&#10;    private void SetVideoFormat(IntPtr chroma, uint width, uint height, ref uint pitches, ref uint lines)&#10;    {&#10;        ArgumentOutOfRangeException.ThrowIfNegative(lines);&#10;        ArgumentOutOfRangeException.ThrowIfNegative(pitches);&#10;        // Use RV32 (BGRA) format - native to Avalonia for optimal quality&#10;        Marshal.Copy(&quot;RV32&quot;u8.ToArray(), 0, chroma, 4);&#10;        &#10;        _videoHeight = height;&#10;        _videoPitch = width * 4; // 4 bytes per pixel (BGRA)&#10;        &#10;        pitches = _videoPitch;&#10;        lines = height;&#10;    }&#10;&#10;    private void AllocateVideoBuffer()&#10;    {&#10;        var bufferSize = GetBufferSize();&#10;        &#10;        lock (_bufferLock)&#10;        {&#10;            FreeVideoBuffer();&#10;            _videoBuffer = Marshal.AllocHGlobal(bufferSize);&#10;        }&#10;    }&#10;&#10;    private void CreateBitmap(uint width, uint height)&#10;    {&#10;        // Post bitmap creation to the UI thread without blocking the caller. If a bitmap with the&#10;        // same size already exists, reuse it. Creating a new bitmap every frame causes lots of&#10;        // allocations and can lead to steadily increasing memory usage.&#10;        Dispatcher.UIThread.Post(() =&gt;&#10;        {&#10;            var pixelSize = new Avalonia.PixelSize((int)width, (int)height);&#10;            var dpi = new Avalonia.Vector(96, 96);&#10;&#10;            if (CurrentFrame != null &amp;&amp; CurrentFrame.PixelSize == pixelSize)&#10;                return; // reuse existing bitmap&#10;&#10;            // Create and publish the new WriteableBitmap instance once per format/size change&#10;            CurrentFrame = new WriteableBitmap(pixelSize, dpi, PixelFormat.Bgra8888, AlphaFormat.Opaque);&#10;        }, DispatcherPriority.Normal);&#10;    }&#10;&#10;    private IntPtr LockVideo(IntPtr opaque, IntPtr planes)&#10;    {&#10;        lock (_bufferLock)&#10;        {&#10;            Marshal.WriteIntPtr(planes, _videoBuffer);&#10;        }&#10;        return IntPtr.Zero;&#10;    }&#10;&#10;    private void DisplayVideo(IntPtr opaque, IntPtr picture)&#10;    {&#10;        // Fast-path checks&#10;        if (!IsVideoReady()) return;&#10;&#10;        // Throttle to avoid flooding the UI thread. If frames arrive faster than TargetFps, drop them.&#10;        var now = Environment.TickCount64;&#10;        var minInterval = 1000 / TargetFps;&#10;        if (now - Interlocked.Read(ref _lastRenderTicks) &lt; minInterval)&#10;            return;&#10;        Interlocked.Exchange(ref _lastRenderTicks, now);&#10;&#10;        // Post a short copy operation to the UI thread. Hold the native buffer lock only for the&#10;        // duration of the copy to prevent races with allocation/free.&#10;        Dispatcher.UIThread.Post(() =&gt;&#10;        {&#10;            if (!IsVideoReady()) return;&#10;&#10;            lock (_bufferLock)&#10;            {&#10;                if (_videoBuffer == IntPtr.Zero || CurrentFrame == null) return;&#10;&#10;                var bufferSize = GetBufferSize();&#10;                using var frameBuffer = CurrentFrame.Lock();&#10;                unsafe&#10;                {&#10;                    Buffer.MemoryCopy(_videoBuffer.ToPointer(), frameBuffer.Address.ToPointer(), bufferSize, bufferSize);&#10;                }&#10;            }&#10;        }, DispatcherPriority.Render);&#10;    }&#10;&#10;    private void CleanupVideo(ref IntPtr opaque)&#10;    {&#10;        lock (_bufferLock)&#10;        {&#10;            FreeVideoBuffer();&#10;        }&#10;    }&#10;    &#10;    #endregion&#10;&#10;    #region Frame Processing&#10;    &#10;    private bool IsVideoReady()&#10;    {&#10;        return CurrentFrame != null &amp;&amp; _videoBuffer != IntPtr.Zero;&#10;    }&#10;    &#10;    #endregion&#10;&#10;    #region Helper Methods&#10;    &#10;    private int GetBufferSize()&#10;    {&#10;        return (int)(_videoPitch * _videoHeight);&#10;    }&#10;&#10;    private void FreeVideoBuffer()&#10;    {&#10;        if (_videoBuffer != IntPtr.Zero)&#10;        {&#10;            Marshal.FreeHGlobal(_videoBuffer);&#10;            _videoBuffer = IntPtr.Zero;&#10;        }&#10;    }&#10;&#10;    private void OnPropertyChanged([CallerMemberName] string? propertyName = null)&#10;    {&#10;        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));&#10;    }&#10;    &#10;    #endregion&#10;&#10;    #region Disposal&#10;    &#10;    public void Dispose()&#10;    {&#10;        if (_isDisposed) return;&#10;        &#10;        _player.Stop();&#10;        _player.Dispose();&#10;        &#10;        lock (_bufferLock)&#10;        {&#10;            FreeVideoBuffer();&#10;        }&#10;        &#10;        _isDisposed = true;&#10;        // no finalizer declared&#10;    }&#10;    &#10;    #endregion&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>